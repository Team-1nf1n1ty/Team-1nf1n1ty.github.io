[{"content":"tl;dr  Analyze the source code - decrypted cipher should contain \u0026quot;FwordCTF\u0026quot; Send an AES encrypted \u0026quot;FwordCTF\u0026quot; payload and the key, and get the flag  Source Code We are given the source code,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  #!/usr/bin/env python3.8 from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import sys, os FLAG = b\u0026#34;FwordCTF{###############################################################}\u0026#34; WELCOME = \u0026#39;\u0026#39;\u0026#39; Welcome to Enc/Dec Oracle. \u0026#39;\u0026#39;\u0026#39; key = os.urandom(32) print(key.hex()) def xor(a, b): return bytearray([a[i % len(a)] ^ b[i % len(b)] for i in range(max(len(a), len(b)))]) def encrypt(msg): aes = AES.new(key, AES.MODE_ECB) if len(msg) % 16 != 0: msg = pad(msg, 16) cipher = aes.encrypt(msg) cipher = xor(cipher, key) return cipher print(key.hex(), encrypt(b\u0026#34;FwordCTF\u0026#34;).hex()) def decrypt(cipher, k): aes = AES.new(k, AES.MODE_ECB) cipher = xor(cipher, k) msg = unpad(aes.decrypt(cipher), 16) return msg class Leaky_Blinders: def __init__(self): print(WELCOME + f\u0026#34;Here is the encrypted flag : {encrypt(FLAG).hex()}\u0026#34;) def start(self): try: while True: print(\u0026#34;\\n1- Encrypt\u0026#34;) print(\u0026#34;2- Decrypt\u0026#34;) print(\u0026#34;3- Leave\u0026#34;) c = input(\u0026#34;\u0026gt; \u0026#34;) if c == \u0026#39;1\u0026#39;: msg = os.urandom(32) cipher = encrypt(msg) if all(a != b for a, b in zip(cipher, key)): print(cipher.hex()) else: print(\u0026#34;Something seems leaked !\u0026#34;) elif c == \u0026#39;2\u0026#39;: k = bytes.fromhex(input(\u0026#34;\\nKey : \u0026#34;)) cipher = bytes.fromhex(input(\u0026#34;Ciphertext : \u0026#34;)) flag = decrypt(cipher, k) if b\u0026#34;FwordCTF\u0026#34; in flag: print(f\u0026#34;Well done ! Here is your flag : {FLAG}\u0026#34;) else: sys.exit(\u0026#34;Wrong key.\u0026#34;) elif c == \u0026#39;3\u0026#39;: sys.exit(\u0026#34;Goodbye :)\u0026#34;) except Exception: sys.exit(\u0026#34;System error.\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: challenge = Leaky_Blinders() challenge.start()   This is the part we are interested in,\n54 55 56 57 58 59  elif c == \u0026#39;2\u0026#39;: k = bytes.fromhex(input(\u0026#34;\\nKey : \u0026#34;)) cipher = bytes.fromhex(input(\u0026#34;Ciphertext : \u0026#34;)) flag = decrypt(cipher, k) if b\u0026#34;FwordCTF\u0026#34; in flag: print(f\u0026#34;Well done ! Here is your flag : {FLAG}\u0026#34;)   We can easily bypass this check by providing our own cipher and key, note the condition if b\u0026quot;FwordCTF\u0026quot; in flag:, as long as our decrypted text contains \u0026quot;FwordCTF\u0026quot;, we\u0026rsquo;ll get our flag.\nSolution I\u0026rsquo;ve written a simple Python script to do the bypass discussed before,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import pwn from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import os key = os.urandom(32) def xor(a, b): return bytearray( [a[i % len(a)] ^ b[i % len(b)] for i in range(max(len(a), len(b)))] ) def encrypt(msg): aes = AES.new(key, AES.MODE_ECB) if len(msg) % 16 != 0: msg = pad(msg, 16) cipher = aes.encrypt(msg) cipher = xor(cipher, key) return cipher conn = pwn.remote(\u0026#34;52.149.135.130\u0026#34;, 4869) conn.recvuntil(b\u0026#34;\u0026gt; \u0026#34;) conn.sendline(b\u0026#34;2\u0026#34;) conn.recvuntil(b\u0026#34;Key : \u0026#34;) conn.sendline(key.hex().encode()) conn.recvuntil(b\u0026#34;Ciphertext : \u0026#34;) conn.sendline(encrypt(b\u0026#34;FwordCTF\u0026#34;).hex().encode()) print(conn.recv(2014))   Flag FwordCTF{N3v3r_x0r_w1thout_r4nd0m1s1ng_th3_k3y_0r_m4yb3_s3cur3_y0ur_c0d3}\n .emojify { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; font-size: 2rem; vertical-align: middle; } @media screen and (max-width:650px) { .nowrap { display: block; margin: 25px 0; } }  ","permalink":"https://1nf1n1ty.team/blog/posts/writeups/fwordctf/2021/leaky-blinders/","summary":"tl;dr  Analyze the source code - decrypted cipher should contain \u0026quot;FwordCTF\u0026quot; Send an AES encrypted \u0026quot;FwordCTF\u0026quot; payload and the key, and get the flag  Source Code We are given the source code,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  #!","title":"Leaky Blinders - FwordCTF 2021"}]